package checkers.inference.model;

import org.checkerframework.javacutil.AnnotationUtils;
import org.checkerframework.javacutil.BugInCF;

import checkers.inference.qual.VarAnnot;

import javax.lang.model.element.AnnotationMirror;

/**
 * A ConstantSlot holds an annotation in the real type system to allow
 * constraints to be uniformly expressed over Slots.
 * 
 * Each AnnotationMirror in the real type system when used is held in a
 * ConstantSlot with a unique ID as assigned by the {@link SlotManager}.
 */
public class ConstantSlot extends Slot {

    /**
     * The annotation in the real type system that this slot is equivalent to
     */
    private AnnotationMirror annotation;

    /**
     * Create a ConstantSlot with the given annotation location.
     * 
     * @param location
     *            Used to locate this constant in code, the location should point to
     *            the tree that has the inherent constant annotation
     *            <p>
     *            eg {@code class MyClass { String s = "a"; } }
     *            <p>
     *            The ASTPath for the ConstantSlot( NonNull ) generated by "a" would
     *            be the path from the root of the compilation unit to the tree "a"
     *            <p>
     *            Note: For now, ConstantSlot ASTPaths are used solely for debugging
     *            purposes, as ConstantSlot annotations never need to be inserted
     *            into Jaif Files
     * @param id
     *            unique ID for the constant
     * @param annotation
     *            The actual AnnotationMirror that this ConstantSlot represents.
     *            This AnnotationMirror should be valid within the type system for
     *            which we are inferring annotations.
     */
    public ConstantSlot(int id, AnnotationLocation location, AnnotationMirror annotation) {
        super(id, false, location);
        checkAndSetValue(annotation);
    }

    /**
     * Create a ConstantSlot with a default location of
     * {@link AnnotationLocation#MISSING_LOCATION}.
     * 
     * @param id
     *            unique ID for the constant
     * @param annotation
     *            The actual AnnotationMirror that this ConstantSlot represents.
     *            This AnnotationMirror should be valid within the type system for
     *            which we are inferring annotations.
     */
    public ConstantSlot(int id, AnnotationMirror annotation) {
        super(id, false);
        checkAndSetValue(annotation);
    }

    private void checkAndSetValue(AnnotationMirror annotation) {
        if (AnnotationUtils.areSameByClass(annotation, VarAnnot.class)) {
            throw new BugInCF(
                    "Invalid attempt to create a ConstantSlot with VarAnnot as annotation: "
                            + annotation);
        }
        this.annotation = annotation;
    }

    @Override
    public <SlotEncodingT> SlotEncodingT serialize(Serializer<SlotEncodingT, ?> serializer) {
        return serializer.serialize(this);
    }

    /**
     * @return The "real" annotation that this ConstantSlot represents.
     */
    public AnnotationMirror getAnnotation() {
        return this.annotation;
    }

    @Override
    public String toString() {
        return annotation.toString();
    }
}
