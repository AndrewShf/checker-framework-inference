package checkers.inference;

import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;
import org.checkerframework.framework.source.Result;
import org.checkerframework.framework.source.SourceChecker;
import org.checkerframework.framework.type.QualifierHierarchy;
import org.checkerframework.javacutil.AnnotationUtils;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import javax.lang.model.element.AnnotationMirror;

import checkers.inference.model.CombineConstraint;
import checkers.inference.model.ComparableConstraint;
import checkers.inference.model.ConstantSlot;
import checkers.inference.model.Constraint;
import checkers.inference.model.EqualityConstraint;
import checkers.inference.model.InequalityConstraint;
import checkers.inference.model.PreferenceConstraint;
import checkers.inference.model.Slot;
import checkers.inference.model.SubtypeConstraint;
import checkers.inference.model.VariableSlot;

/**
 * Constraint manager holds constraints that are generated by InferenceVisitor.
 *
 * @author mcarthur
 *
 */
public class ConstraintManager {

    private boolean ignoreConstraints = false;

    private final Set<Constraint> constraints = new HashSet<Constraint>();

    private final BaseAnnotatedTypeFactory realTypeFactory;

    private final QualifierHierarchy qualHierarchy;

    private final SourceChecker checker;

    public ConstraintManager(BaseAnnotatedTypeFactory realTypeFactory) {
        this.realTypeFactory = realTypeFactory;
        this.qualHierarchy = realTypeFactory.getQualifierHierarchy();
        this.checker = realTypeFactory.getContext().getChecker();
    }

    public Set<Constraint> getConstraints() {
        return constraints;
    }

    private void add(Constraint constraint) {
        if (!ignoreConstraints) {
            constraints.add(constraint);
        }
    }

    private void addAll(Collection<? extends Constraint> constraints) {
        if (!ignoreConstraints) {
            for (Constraint constraint : constraints) {
                add(constraint);
            }
        }
    }

    public void startIgnoringConstraints() {
        this.ignoreConstraints = true;
    }

    public void stopIgnoringConstraints() {
        this.ignoreConstraints = false;
    }

    public void addSubtypeConstraint(Slot subtype, Slot supertype) {

        if (supertype instanceof ConstantSlot) {
            ConstantSlot superConstant = (ConstantSlot) supertype;
            Set<? extends AnnotationMirror> tops = qualHierarchy.getTopAnnotations();
            if (tops.contains(superConstant.getValue())) {
                return;
            } else if (subtype instanceof ConstantSlot) {
                ConstantSlot subConstant = (ConstantSlot) subtype;
                if (!qualHierarchy.isSubtype(subConstant.getValue(), superConstant.getValue())) {
                    checker.report(Result.failure("subtype.type.incompatible", subtype, supertype));
                }
            }
        } else if (subtype instanceof ConstantSlot) {
            ConstantSlot subConstant = (ConstantSlot) subtype;
            Set<? extends AnnotationMirror> bottoms = qualHierarchy.getBottomAnnotations();
            if (bottoms.contains(subConstant.getValue())) {
                return;
            }
        }
        this.add(new SubtypeConstraint(subtype, supertype));
    }

    public void addEqualityConstraint(Slot first, Slot second) {
        if (first instanceof ConstantSlot && second instanceof ConstantSlot) {
            ConstantSlot firstConstant = (ConstantSlot) first;
            ConstantSlot secondConstant = (ConstantSlot) second;
            if (!areSameType(firstConstant.getValue(), secondConstant.getValue())) {
                checker.report(Result.failure("equality.type.incompatible", first, second));
            }
        }
        this.add(new EqualityConstraint(first, second));
    }

    public void addInequalityConstraint(Slot first, Slot second) {
        if (first instanceof ConstantSlot && second instanceof ConstantSlot) {
            ConstantSlot firstConstant = (ConstantSlot) first;
            ConstantSlot secondConstant = (ConstantSlot) second;
            if (areSameType(firstConstant.getValue(), secondConstant.getValue())) {
                checker.report(Result.failure("inequality.type.incompatible", first, second));
            }
        }
        this.add(new InequalityConstraint(first, second));
    }

    public void addComparableConstraint(Slot first, Slot second) {
        if (first instanceof ConstantSlot && second instanceof ConstantSlot) {
            ConstantSlot firstConstant = (ConstantSlot) first;
            ConstantSlot secondConstant = (ConstantSlot) second;
            if (!qualHierarchy.isSubtype(firstConstant.getValue(), secondConstant.getValue())
                    && !qualHierarchy.isSubtype(secondConstant.getValue(), firstConstant.getValue())) {
                checker.report(Result.failure("comparable.type.incompatible", first, second));
            }
        }

        this.add(new ComparableConstraint(first, second));
    }

    public void addCombineConstraint(Slot target, Slot decl, Slot result) {
        this.add(new CombineConstraint(target, decl, result));
    }

    public void addPreferenceConstraint(VariableSlot variable, ConstantSlot goal, int weight) {
        this.add(new PreferenceConstraint(variable, goal, weight));
    }

    private boolean areSameType(AnnotationMirror m1, AnnotationMirror m2) {
        return AnnotationUtils.areSameIgnoringValues(m1, m2);
    }
}
